---
title: NestJS
date: '2023-11-12'
categories: coding
tags: "네스트"
description: "02"
---
<HeadingNavigator />

### NestJS
- 효율적이고 스케일링이 쉬운 서버를 만들기 위한 Node.js 백엔드 프레임워크다
- Express를 기반으로 하고 있다
- 자체적으로 서버 아키텍쳐를 제공한다. 모듈과 모듈이 겹겹이 쌓여 하나의 서버를 구성한다
- 이 각각의 모듈은 컨트롤러(리졸버, 게이트웨이) / 서비스 / 리포지토리(엔티티)로 이루어진다

### NestJS의 구조
NestJS는 이런 단위 모듈들로 구성되어 있다. 그리고 각각의 모듈은 MVC 패턴을 지원한다.
- <u>엔티티</u>: TypeORM을 사용하여 모델을 작성한다.
- <u>컨트롤러</u>: 클라이언트의 요청을 받아 서비스에 전달한다.
- <u>서비스</u>: 클라이언트에서 넘겨받은 정보를 기반으로 비지니스 로직을 처리한다. 이때 엔티티를 기반으로 리포지토리를 생성하여 DB 로직을 수행한다.


<br/>
이렇게 캡슐화된 하나의 모듈은 다른 모듈과 연결되기도 하고, 종국에는 `app.module` 위에 쌓임으로써 하나의 서버를 구성한다.  
그러면 최상단인 `main.ts`에서 이 `app.module`을 실행하는 것으로써 서버가 작동한다.
```ts main.ts
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
bootstrap();
```

### NestJS의 라이프 사이클
<Img src='/images/nest/cycle.png' />
<figcaption>API 처리 흐름</figcaption>
<br/>
<b>모듈이 실행되는 과정</b>
- 클라이언트에서 API 요청을 하면 NestJS는 라우터를 통해 컨트롤러로 요청을 전달한다
- 컨트롤러는 서비스에 구현된 응답 로직(들)을 불러와 실행한다
- 엔티티를 작성하고, 서비스는 이를 기반으로 한 리포지토리를 통해 DB 로직을 수행한다
- 적재적소에서 파이프 라인을 활용한다. 유효성 검사, 접근 권한 검사, 요청/응답 데이터 재가공 등 다양한 작업을 통해 어플리케이션의 완성도를 높일 수 있다

<br/>
---
<br/>
이어지는 내용은 큰틀에서 NestJS의 중심을 이루는 부분이다. 디테일한 내용은 이어지는 포스트에서 다룰 예정이라 간단히만 정리한다.  

### Controller
컨트롤러는 클라이언트의 요청을 받아 그에 필요한 서비스를 내보내는 곳이다. 클라이언트와 서비스 둘 사이의 가교 역할을 한다. 비즈니스 로직을 구현하는 부분을 서비스에 넘김으로써 그 역할이 한결 돋보이게 됐다.  
그 역할이란 관제탑 같아서, 클라이언트에서 넘어오는 `Body`나 `Query` 등등의 정보를 쉽게 식별하게 한다. 그러면서 그 정보를 서비스들에 전달한다.    
엔드포인트의 이정표를 세우는 것도 여기에서다. 두 가지 방법이 있다.
<br/>
1. <a>@Controller(  )</a>: 해당 컨트롤러(클래스)의 모든 엔드포인트에 베이스로 깔리는 경로
2. <a>@Method(  )</a>: 해당 메소드(함수)에만 적용되는 경로
 
```ts 예시.tsx
@Controller('posts')
export class PostsController {
  // '/posts/:postId'로 보내는 Get 요청
  @GET(':postId')
  getPosts(
    @Param('postId') postId: string,
  ){
    return somethingServiceLogic();
  }
}
```
예시 코드를 보면
1. 컨트롤러의 모든 엔드포인트에 대해 접두어 '/posts'가 붙는다
2. 이어 `getPosts(  )` 메써드에는 개별 경로 ':postId'가 붙는다
3. 그래서 엔드포인트는 '/posts/:postId'다
4. 이 경로에 대한 GET 요청을 `getPosts(  )`가 전담한다


### Service
서비스는 비지니스 로직을 실질적으로 처리하는 곳이다. 컨트롤러에서 넘겨받는 정보들로 DB 작업을 수행한다. 또한 다른 모듈의 서비스를 호출하여 로직을 처리하기도 한다.  
<br/>
컨트롤러와 분리됨으로써 얻는 이점은 서비스 쪽에서도 있어서, 코드의 가독성이 좋아지고 재사용성이 높아진다. 분리로 인해 응답 로직이 특정 요청에만 얽매이지 않으면서 다른 요청, 다른 서비스에서도 사용될 수 있다.  
또한 필요한 소스를 파라미터에 놓고 자신의 로직에 집중, 개진할 수 있는 점도 개발할 때 플러스 요소다(어떤 소스를 받아야 할지, 받을 수 있는지는 컨트롤러에서 고민한다).


### Entity
엔티티는 DB 테이블을 정의하는 곳이다. `TypeORM`를 쓰면 당장 SQL 언어를 모르더라도 테이블을 작성할 수 있는데 이는 데코레이터를 적극적으로 사용하는 NestJS와도 잘 어울려서 이질감이 없다.  
<br/>
`class-validator`, `class-transformer` 라이브러리와 연계하여 유효성 검사와 데이터 변환을 쉽게 할 수 있다.

<br/>
---

#### 참고링크
- [NestJS 공식문서](https://docs.nestjs.com/)