---
title: 타깃과 소스
date: '2024-04-10'
tags:
  - 자바스크립트
categories: coding
description: study
---



프로그램 내의 모든 변수는 타깃 아니면 소스다. 즉 할당의 타깃 또는 값의 소스다. LHS와 RHS 로 구분짓기도 한다. 값의 소스로 올 때는 우변, 타깃으로 오는 경우 좌변에 위치하는 경우가 일반적이기 때문.

그중 함수 선언은 타깃 참조의 특수한 케이스다. 
```ts
 function something(param){
	 ...
 }
```

이 코드에서 함수명 something은 컴파일 타임에 선언되고, = function(param) 역시 컴파일 과정에서 처리된다. 함수 선언식에서 타깃인 함수명과 소스인 함수의 관계는 할당문이 실행될 때가 아닌 스코프가 구성되기 시작하는 시점에 자동으로 설정된다.



 ### 함수 선언식과 표현식의 차이

선언식은 호이스팅 되고 표현식은 호이스팅 되지 않는다.
두드러지는 차이점은 기명 함수일 때 드러난다.

```ts
function FuncOne(){
	console.log(FuncOne);
}

const FuncTwo = function AnotherFunc(){
	console.log(AnotherFunc);
}
	
FuncOne();  // function FuncOne()
FuncTwo();  // function FuncTwo()
AnotherFunc();  // ReferenceError: AnotherFunc is not defined.
```

함수 표현식에서 function으로 기명 함수가 할당됐을 때, 함수 선언식과 똑같이 이름을 부를 수 있을 것 같지만 그렇지 않다. 외부스코프에서는 함수의 이름을 부를 수 없고, 다만 함수 스코프 안에서 스스로를 재귀적으로 호출할 수 있을 뿐이다.
(정확히는 함수 스코프 안에 이름이 생성되는 것이 아니라 그 밖에 암시적 스코프를 생성한다. 이름은 읽기 전용이다.)

익명함수로 쓰는 경우가 많지만 이 경우 재귀적으로 자신을 호출할 방법이 없다.



### 화살표 함수

화살표 함수는 익명으로 취급된다.
그러면 function을 통해 선언하는 일반 함수와 화살표 함수는 스코프 측면에서 다르게 작동할까? 아니다.
화살표 함수는 익명이라는 특성 (그리고 명확한 형식이 없다는 특성) 이외에는 function을 사용해 선언한 함수와 동일한 렉시컬 스코프 규칙을 적용받는다. 다시말해 화살표 함수도 별도의 내부 중첩 스코프를 만든다. 이 중첩 스코프에 선언된 변수는 일반 함수의 본문 내에 선언한 변스 스코프와 동일한 효력을 가진다.


> 선언을 하든 표현식을 쓰든, 함수를 정의하면 새로운 스코프가 만들어진다. 스코프 중첩을 어떻게 만들었는지에 따라 스코프 계층 관계가 만들어지는데, 이를 스코프 체인이라 부른다. 스코프 체인은 바깥쪽 방향으로만 접근 가능하다.
> 새 스코프가 생기면 변수를 담을 새 공간이 만들어진다. 만약 바깥 스코프와 내부 스코프에 있는 변수의 이름이 같으면, 바깥쪽에 있는 변수는 암전되고 가까이 있는 변수에만 접근할 수 있다.

### 전역 스코프

최신 JS는 대부분의 코드를 모듈이나 함수 안에 갈무리한다. 그럼 전역 스코프는 어떤 점에서 유효하고 쓸모가 있을까?

**파일을 하나로 모으는 세 가지 방법**
1. ES 모듈을 사용해서 import/export 하는 법
2. 번들러가 관여하여 커다란 파일 안에 코드를 통합하는 법(UMD)
3. 전역 스코프를 활용하는 방법

**전역 변수를 사용하는 순간들**
1. JS 내장 기능(메서드)을 사용할 때
2. 특정 호스팅 환경(브라우저 등)에서 제공하는 내장 기능을 사용할 때

전역 스코프에 변수를 선언하는 건 개발자에게 자살이나 마찬가지다. 하지만 JS에 관여하는 프로그램들이 전역 스코프를 <q>접착제</q> 삼아 파일을 모으고 실행한다는 사실은 부인할 수 없다.


식별자가 전역 스코프에 선언된다는 말은 전역 스코프 객체(대개 window)의 프로퍼티를 통해 해당 식별자에 접근할 수 있다는 말과 같다.
그럼 다음의 경우 쉐도잉은 어떻게 될까?
```ts
window.something = 123;
let something = 456;

console.log(something);
console.log(window.something);
```

let으로 선언한 변수가 프로퍼티도 덮어쓸까? 답은 아니다.
let과 const를 사용한 변수는 전역 프로퍼티에 추가되지 않는다. 이렇게 전역 객체 프로퍼티와 전역 스코프에 등록된 변수가 다르게 값을 가지는 건 그리 좋지 못하다. 분명 실수할 구석이 나온다.
전역에 무언가를 선언할 때는 var를 쓰는 것이 실수를 막는 좋은 방법이다.


**DOM 전역변수**
DOM 요소에 id 속성(attribute)을 추가하면 해당 id는 전역 변수로 등록된다. 이 변수를 통해 해당 DOM 요소에 접근하는 게 가능하다.
```html
<div id='first' />
```
```ts
first;   // <div id='first' />
window['first'];   // <div id='first' />
```

하지만 자동으로 등록된 전역 변수는 가급적 사용하지 않는 게 좋다.

### 웹워커
웹워커에서는 DOM에 접근할 수 없으므로 window 객체는 사용하지 못한다. 대신 전역 객체 역할을 하는 키워드는 `self`다. 마찬가지로 var/function은 미러링 프로퍼티를 생성하지만, let을 비롯한 이외의 선언은 미러링 프로퍼티를 생성하지 않는다.


### ES 모듈
모듈(파일)의 최상위에 작성되는 코드는 전역 스코프가 아니라 모듈 스코프(또는 모듈 전역 스코프)로 들어간다.
이는 모듈 내 모든 컨텐츠가 함수에 래핑된 것처럼 묶여서 처리되고, 전역 스코프의 하위 스코프가 됨을 의미한다. 바깥 스코프인 전역 스코프 변수에 접근할 수 있다.

### NodeJS
모든 파일을 ES모듈 또는 CommonJS 모듈 패턴으로 처리한다. 즉 각 JS 파일이 자체의 스코프를 가진다.
이는 위에 설명한 대로 코드를 함수로 감싸, var/function 선언이 전역변수를 오염시키는 것을 방지하기 위함이다.
```ts
function Module(module, require, __dirname, ...){
	코드들
}
```

코드를 감싸는 이런 함수, 아규먼트들은 실제로 볼 일은 없고 모든 모듈 스코프에 자동으로 주입된다. NodeJS에서 전역변수를 정의하는 법은 global 변수에 프로퍼티를 추가하는 방법이 유일하다.

ES2020부터는 globalThis로 window, global, self를 모두 포괄할 수 있게 되었다.




# 호이스팅
식별자는 컴파일타임 때 각자의 스코프에 등록된다. 그리고 자신이 속한 스코프가 생성될 때 해댕 스코프의 최상단에서 시작한다.
이렇게 선언이 스코프 아래에 있더라도 스코프 시작 부분에서  변수의 가시성이 확보되는 현상을 호이스팅이라 한다. 

### 함수 호이스팅
함수 선언문으로 작성한 코드는 식별자가 스코프 최상단에 등록되는 동시에 함수 참조로 그 값이 자동으로 초기화된다. 이 때문에 위치가 어디에 있든 자유롭게 호출할 수 있다.

함수 호이스팅 식별자는 var 변수 식별자와 같이 함수 스코프를 가진다.



> 호이스팅을 코드 재정렬 매커니즘이라고 생각하는 게 이해에는 도움을 주지만 정확히진 않다. JS 엔진은 실제 코드를 재정렬하지 않기 때문이다. 프로그램의 모든 스코프 경계와 선언문을 정확히 찾을 수 있는 유일한 방법은 코드를 파싱하는 것뿐이다.
> 파싱없이 프로그램을 실행할 방법은 그 어디에도 없다. 호이스팅은 런타임에 일어나는 동작이 아니라 컴파일 타임에 일어나는 작업의 일부로 바라봐야 한다.


# 중복 선언
동일한 스코프에서 변수가 재선언 되는 경우가 있을까? 없다.
let과 const의 경우 재선언이 불가하며 syntaxError 오류를 낸다.
var의 경우 재선언은 아무 의미가 없다.

### const 재선언
const는 선언과 초기화가 반드시 같이 일어나야 한다.
const 변수를 재선언한다면 재할당도 따르게 되는데, const 변수의 재할당은 막혀 있다. 따라서 기술적인 이유로 재선언도 할 수 없다.

> syntaxError와 TypeError의 차이
> 구문오류는 프로그램 실행전에 발생하는 오류로, 실행조차 못하게 한다. 반면 타입에러는 프로그램이 실행 중인 상태에서 나타나는 오류다. 

### 반복문
반복문에서는 반복이 돌아갈 때마다 자체적인 새 스코프가 생성된다.
반복문에서 var를 사용시 바깥 함수스코프에 부착되기 때문에 위험하다.
for 반복문, for in, for of, while 모두 let 변수를 사용해 변수의 값이 재할당되지 않도록 한다.
let을 쓸 경우 각각의 변수는 인스턴스 블록 스코프에 생성되며 재선언되지 않는다.

const를 사용해도 괜찮지만, 일반적인 반복문에서는 안전하지 않을 수 있다.
```ts
for (const i = 0; i < 2; i++;) {
	// 첫번째 반복문 실행 이후 TypeError: Assignment to constant variable 발생
}
```

하지만 각각의 블록스코프마다 변수가 생성된다면 이 에러는 납득이 가지 않는다.
그런데 실제 일반적인 반복문이 작동하는 개념적 모델을 나타내면 다음과 같다

```ts
const $$i = 0;
for (; $$i < 2; $$i++;) {
	const i = $$i;
}
```

변수 i는 각각의 블록스코프 내에 한번만 선언되지만, 실제 그 할당값은 블록스코프 외부, 반복문이 선언된 스코프에 위치해서 참조가 이루어진다. 그리고 그 변수 역시 const로 선언된다.
하지만 const는 재할당이 불가능하기 때문에 두번째 반복문부터 오류가 발생하는 것이다.
따라서 const를 굳이 사용하고 싶다면 while 반복문을, 아니라면 let 변수를 사용하면 된다.



let/const를 초기화하는 방법은 선언문에 할당을 붙이는 것이다.
선언과 할당을 따로 할 시에 ReferenceError가 난다.

TDZ: (호이스팅에 의해)변수는 확인되지만 초기화가 이루어지지 않아 접근이 막혀있는 시간대. 엄밀히 말하면 var도 TDZ가 있지만 길이가 0이므로 관찰할 수 없다. let/const만 TDZ가 확인된다.
TDZ를 피하기 위해 들여야 하는 습관: let/const 선언은 스코프 최상단에 둔다.
let의 경우 변수를 사용하는 시점 이전에 선언과 할당이 각각 이루어지더라도 TDZ를 피할 수 있다. var와 달리 초기화가 자동으로 일어나지 않을 뿐이다.

그럼 let/const 변수의 TDZ는 왜 존재할까?


### var 변수 = undefined; 와 var 변수; 가 다를 수 있는 상황

```ts
var age = 12;
console.log(age);   // 12

var age;
console.log(age);   // 12

var age = undefined;
console.log(age);   // undefined
```

var 변수는 호이스팅시 할당이 없으면 undefined로 초기화된다.
하지만 이미 값을 할당받은 상태에서 `var age`를 재선언하는 것은 아무 효력도 갖지 않는다.
이 경우 초기화를 하고자 한다면 직접 undefined로 할당해줘야 함


